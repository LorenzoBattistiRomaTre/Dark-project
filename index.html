<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Dark Graph Timeline</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }
    svg {
      width: 100%;
      height: 100%;
      display: block;
    }
    .world-bg {
      opacity: 1;
    }
    .node {
      fill: black;
      stroke: white;
      stroke-width: 1px;
    }
    .link {
      stroke: #ccc;
      stroke-opacity: 0.8;
      marker-end: url(#arrow);
    }
    .tooltip {
      position: absolute;
      background: #333;
      color: #fff;
      padding: 5px 10px;
      border-radius: 4px;
      pointer-events: none;
      font-size: 36px;
      transform-origin: top left;
    }
    .axis text {
      fill: #222;
      font-size: 12px;
    }
    .axis line,
    .axis path {
      stroke: #444;
    }
  </style>
</head>
<body>
  <svg></svg>
  <div class="tooltip" style="display: none;"></div>
  <script>
    const svg = d3.select("svg");
    const tooltip = d3.select(".tooltip");
    const width = window.innerWidth;
    const height = window.innerHeight;

    const colorMap = {
      "Martha": "#fbe18c",
      "Jonas": "#a1e6a1",
      "Origin": "#b6d8ff",
    };

    const worlds = ["Martha", "Jonas", "Origin"];

    const zoomLayer = svg.append("g").attr("class", "zoom-layer");

    const zoom = d3.zoom()
      .scaleExtent([0.2, 10])
      .on("zoom", (event) => {
        zoomLayer.attr("transform", event.transform);
        tooltip.style("transform", "scale(1)");
      });

    svg.call(zoom);

    d3.json("dark_graph_data_cleaned.json").then(data => {
      const xScale = d3.scalePoint()
        .domain(data.event_dates)
        .range([150, width - 150])
        .padding(0.5);

      const worldBandHeight = height / worlds.length;
      const yScaleWorld = d3.scalePoint()
        .domain(worlds)
        .range([worldBandHeight / 2, height - worldBandHeight / 2]);

      const yOffsets = {};
      worlds.forEach(world => {
        yOffsets[world] = {};
      });

      const nodeMap = {};
      data.nodes.forEach(node => {
        const world = normalizeWorld(node.world);
        if (!yOffsets[world][node.date]) yOffsets[world][node.date] = [];
        yOffsets[world][node.date].push(node.id);
        nodeMap[node.id] = node;
      });

      const yStep = 20;
      const yOffsetScale = (node) => {
        const world = normalizeWorld(node.world);
        const baseY = yScaleWorld(world);
        const ids = yOffsets[world][node.date];
        const index = ids.indexOf(node.id);
        return baseY + index * yStep - (ids.length - 1) * yStep / 2;
      };

      // Backgrounds
      zoomLayer.selectAll(".world-bg")
        .data(worlds)
        .enter()
        .append("rect")
        .attr("class", "world-bg")
        .attr("x", 0)
        .attr("y", (d, i) => i * worldBandHeight)
        .attr("width", width)
        .attr("height", worldBandHeight)
        .attr("fill", d => colorMap[d]);

      // Links
      zoomLayer.selectAll(".link")
        .data(data.edges)
        .enter()
        .append("line")
        .attr("class", d => `link link-${d.id}`)
        .attr("x1", d => xScale(nodeMap[d.source].date))
        .attr("y1", d => yOffsetScale(nodeMap[d.source]))
        .attr("x2", d => xScale(nodeMap[d.target].date))
        .attr("y2", d => yOffsetScale(nodeMap[d.target]))
        .attr("stroke", "#ccc")
        .attr("stroke-opacity", 0.8)
        .on("mouseover", function(event, d) {
          d3.select(this)
            .attr("stroke", "orange")
            .attr("stroke-width", 3);

          d3.selectAll(`[data-id='${d.source}'], [data-id='${d.target}']`)
            .attr("stroke", "orange")
            .attr("stroke-width", 3);
        })
        .on("mouseout", function(event, d) {
          d3.select(this).attr("stroke", "#ccc").attr("stroke-width", 1);
          d3.selectAll(`[data-id='${d.source}'], [data-id='${d.target}']`)
            .attr("stroke", "white")
            .attr("stroke-width", 1);
        });

      // Nodes
      const nodeSelection = zoomLayer.selectAll(".node")
        .data(data.nodes)
        .enter()
        .append("circle")
        .attr("class", "node")
        .attr("data-id", d => d.id)
        .attr("r", 6)
        .attr("cx", d => xScale(d.date))
        .attr("cy", d => yOffsetScale(d))
        .on("mouseover", (event, d) => {
          const scale = d3.zoomTransform(svg.node()).k;
          tooltip
            .style("display", "block")
            .style("font-size", `36px`)
            .html(`<strong>${d.label}</strong><br>${d.characters.join(", ")}`);
        
        })
        .on("mousemove", event => {
          tooltip
            .style("left", event.pageX + 10 + "px")
            .style("top", event.pageY + "px");
        })
        .on("mouseout", () => tooltip.style("display", "none"));

      // Axes
      const xAxis = d3.axisBottom(xScale).tickSizeOuter(0).tickPadding(10).tickFormat(d => d);
      const yAxis = d3.axisLeft(yScaleWorld);

      // Add X axis
      zoomLayer.append("g")
        .attr("class", "axis")
        .attr("transform", `translate(0, ${height - 10})`)
        .call(g => {
          g.call(xAxis);
          g.selectAll("text")
            .attr("text-anchor", "end")
            .attr("transform", "rotate(-45)")
            .attr("dx", "-0.5em")
            .attr("dy", "0.25em");
        });

      // Add vertical separators for large gaps
      const parseDate = d3.timeParse("%Y-%m-%d");
      const indexedDates = data.event_dates.map((d, i) => ({ d, date: parseDate(d) }));
      const dates = indexedDates.map(e => e.date);
      dates.sort((a, b) => a - b);
      const sortedIndexed = [...indexedDates].sort((a, b) => parseDate(a.d) - parseDate(b.d));

      for (let i = 1; i < sortedIndexed.length; i++) {
        const prevDate = sortedIndexed[i - 1].date;
        const currDate = sortedIndexed[i].date;
        const diffDays = (currDate - prevDate) / (1000 * 3600 * 24);
        const x = xScale(sortedIndexed[i].d);
        let stroke = null;

        if (diffDays > 365) stroke = "#222";
        else if (diffDays > 30) stroke = "#666";

        if (stroke && x !== null) {
          zoomLayer.append("line")
            .attr("x1", x)
            .attr("x2", x)
            .attr("y1", 0)
            .attr("y2", height)
            .attr("stroke", stroke)
            .attr("stroke-width", diffDays > 365 ? 3 : 2)
            .attr("stroke-opacity", 0.3)
            .lower();
        }
      }
      
      // Y Axis
      zoomLayer.append("g")
        .attr("class", "axis")
        .attr("transform", `translate(150, 0)`)
        .call(yAxis);

      svg.append("defs").append("marker")
        .attr("id", "arrow")
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 12)
        .attr("refY", 0)
        .attr("markerWidth", 7)
        .attr("markerHeight", 7)
        .attr("orient", "auto")
        .append("path")
        .attr("d", "M0,-5L10,0L0,5")
        .attr("fill", "#ccc");

      function normalizeWorld(w) {
        if (w.includes("Martha")) return "Martha";
        if (w.includes("Jonas")) return "Jonas";
        return "Origin";
      }
    });
  </script>
</body>
</html>
