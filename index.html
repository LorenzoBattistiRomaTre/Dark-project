<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Dark Graph Timeline - Supernodi</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div id="scroll-container" style="overflow-x: auto; width: 100%; height: 100%;">
    <svg></svg>
  </div>
  <div class="tooltip" style="display: none;"></div>
  <button id="resetView" style="position: absolute; top: 10px; left: 10px; z-index: 10;">Reset Vista Compatta</button>

<script>
const svg = d3.select("svg");
const tooltip = d3.select(".tooltip");
const width = window.innerWidth;
const height = window.innerHeight;
const colorMap = { "Martha": "#fbe18c", "Jonas": "#a1e6a1", "Origin": "#b6d8ff" };
const worlds = ["Martha", "Jonas", "Origin"];
const zoomLayer = svg.append("g").attr("class", "zoom-layer");
const zoom = d3.zoom().scaleExtent([0.2, 10]).on("zoom", (event) => {
  zoomLayer.attr("transform", event.transform);
  tooltip.style("transform", "scale(1)");
});
svg.call(zoom);

svg.append("defs").append("marker")
  .attr("id", "arrow")
  .attr("viewBox", "0 -5 10 10")
  .attr("refX", 12)
  .attr("refY", 0)
  .attr("markerWidth", 7)
  .attr("markerHeight", 7)
  .attr("orient", "auto")
  .append("path")
  .attr("d", "M0,-5L10,0L0,5")
  .attr("fill", "#ccc");

d3.json("dark_graph_data_cleaned.json").then(data => {
const worldBandHeight = height / worlds.length;
const yScaleWorld = d3.scalePoint().domain(worlds).range([worldBandHeight / 2, height - worldBandHeight / 2]);
const nodeMap = {};
data.nodes.forEach(node => {
  nodeMap[node.id] = node;
});

function normalizeWorld(w) {
  if (w.includes("Martha")) return "Martha";
  if (w.includes("Jonas")) return "Jonas";
  return "Origin";
}

const groups = groupNodes();
const allDates = Array.from(new Set(data.nodes.map(d => d.date))).sort();

function groupNodes() {
  const groups = [];
  const visited = new Set();
  data.nodes.forEach(node => {
    if (visited.has(node.id)) return;
    const world = normalizeWorld(node.world);
    const date = node.date;
    const sameDateNodes = data.nodes.filter(n => n.date === date && normalizeWorld(n.world) === world);
    const connected = new Set([node.id]);
    let changed = true;
    while (changed) {
      changed = false;
      data.edges.forEach(edge => {
        const s = edge.source, t = edge.target;
        if (connected.has(s) && sameDateNodes.some(n => n.id === t) && !connected.has(t)) { connected.add(t); changed = true; }
        if (connected.has(t) && sameDateNodes.some(n => n.id === s) && !connected.has(s)) { connected.add(s); changed = true; }
      });
    }
    if (connected.size > 1) {
      groups.push({ ids: Array.from(connected), representative: node, exploded: false });
      connected.forEach(id => visited.add(id));
    } else {
      groups.push({ ids: [node.id], representative: node, exploded: false });
      visited.add(node.id);
    }
  });
  return groups;
}

function computeLayout(nodesToRender) {
  const layout = {};
  const datePadding = 10;
  const baseX = 150;
  let currentX = baseX;

  allDates.forEach(date => {
    const sameDateNodes = nodesToRender.filter(n => n.date === date);
    if (sameDateNodes.length === 0) return;

    let maxR = 0;
    sameDateNodes.forEach(n => {
      n.r = n.isGroup ? 6 + Math.sqrt(n.size) * 2 : 6;
      maxR = Math.max(maxR, n.r);
    });

    sameDateNodes.forEach(n => {
      layout[n.id] = {
        x: currentX,
        y: computeY(sameDateNodes, n)
      };
    });

    currentX += maxR * 2 + datePadding;
  });

  layout.totalWidth = currentX + baseX;
  return layout;
}

function computeY(nodes, node) {
  const sameWorldNodes = nodes.filter(n => normalizeWorld(n.world) === normalizeWorld(node.world));
  const radii = sameWorldNodes.map(n => n.isGroup ? 6 + Math.sqrt(n.size) * 2 : 6);
  const padding = 5;
  let y = yScaleWorld(normalizeWorld(node.world)) - (radii.reduce((a, b) => a + b, 0) + (sameWorldNodes.length - 1) * padding) / 2;
  for (let i = 0; i < sameWorldNodes.length; i++) {
    const current = sameWorldNodes[i];
    const r = radii[i];
    y += r;
    if (current.id === node.id) return y;
    y += r + padding;
  }
}

function render() {
  zoomLayer.selectAll(".node, .link, .world-bg").remove();

  const nodesToRender = [];
  groups.forEach(g => {
    if (g.exploded) {
      g.ids.forEach(id => nodesToRender.push(nodeMap[id]));
    } else {
      const label = g.ids.length === 1 ? nodeMap[g.ids[0]].label : g.ids.length + " eventi";
      nodesToRender.push({ id: g.ids.join(","), label: label, date: g.representative.date, world: normalizeWorld(g.representative.world), isGroup: g.ids.length > 1, group: g, size: g.ids.length });
    }
  });

  const layout = computeLayout(nodesToRender);
  d3.select("#scroll-container svg").attr("width", layout.totalWidth).attr("height", height);

  zoomLayer.selectAll(".world-bg")
    .data(worlds)
    .enter()
    .append("rect")
    .attr("class", "world-bg")
    .attr("x", 0)
    .attr("y", (d, i) => i * worldBandHeight)
    .attr("width", layout.totalWidth)
    .attr("height", worldBandHeight)
    .attr("fill", d => colorMap[d]);

  const idToNode = Object.fromEntries(nodesToRender.map(n => [n.id, n]));

  const edgesToRender = data.edges.map(e => {
    const sourceGroup = groups.find(g => g.ids.includes(e.source));
    const targetGroup = groups.find(g => g.ids.includes(e.target));
    const source = sourceGroup.exploded ? e.source : sourceGroup.ids.join(",");
    const target = targetGroup.exploded ? e.target : targetGroup.ids.join(",");
    return { source, target };
  });

  zoomLayer.selectAll(".link")
    .data(edgesToRender)
    .enter()
    .append("line")
    .attr("class", "link")
    .attr("x1", d => layout[d.source]?.x)
    .attr("y1", d => layout[d.source]?.y)
    .attr("x2", d => layout[d.target]?.x)
    .attr("y2", d => layout[d.target]?.y)
    .attr("stroke", "#ccc").attr("stroke-opacity", 0.8)
    .attr("marker-end", "url(#arrow)");

  zoomLayer.selectAll(".node")
    .data(nodesToRender)
    .enter()
    .append("circle")
    .attr("class", "node")
    .attr("r", d => d.isGroup ? 6 + Math.sqrt(d.size) * 2 : 6)
    .attr("cx", d => layout[d.id].x)
    .attr("cy", d => layout[d.id].y)
    .on("mouseover", (event, d) => {
      tooltip.style("display", "block").html(`<strong>${d.label}</strong>`);
    })
    .on("mousemove", event => {
      tooltip.style("left", event.pageX + 10 + "px").style("top", event.pageY + "px");
    })
    .on("mouseout", () => tooltip.style("display", "none"))
    .on("click", (event, d) => {
      if (d.isGroup && d.group) {
        d.group.exploded = true;
        render();
      }
    });
}

render();
d3.select("#resetView").on("click", () => {
  groups.forEach(g => g.exploded = false);
  render();
});
});
</script>
</body>
</html>
