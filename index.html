<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Dark Graph Timeline</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <button id="resetView">Reset Vista Compatta</button>
  <svg></svg>
  <div class="tooltip" style="display: none;"></div>
  <div id="side-panel">
    <button id="close-panel-btn" style="
      background: #444;
      color: #fff;
      border: none;
      padding: 10px 15px;
      cursor: pointer;
      margin-bottom: 20px;
    ">Chiudi</button>
    <div id="panel-content"></div>
  </div>



  <script>
    const svg = d3.select("svg");
    const tooltip = d3.select(".tooltip");
    const width = window.innerWidth;
    const colorMap = { "Martha": "#fbe18c", "Jonas": "#a1e6a1", "Origin": "#b6d8ff" };
    const worlds = ["Martha", "Jonas", "Origin"];
    const zoomLayer = svg.append("g").attr("class", "zoom-layer");
    const zoom = d3.zoom().scaleExtent([0.2, 10]).on("zoom", (event) => {
      zoomLayer.attr("transform", event.transform);
      tooltip.style("transform", "scale(1)");
    });
    svg.call(zoom);

    svg.append("defs").selectAll("marker")
      .data([
        { id: "arrow", color: "#999" },
        { id: "arrow-red", color: "red" },
        { id: "arrow-green", color: "green" },
        { id: "arrow-purple", color: "purple" },
        
        { id: "arrow-blue", color: "#6495ED" }, //Successful Time Travel
        { id: "arrow-orange", color: "#FF6A00" }, //Failed Time Travel
        { id: "arrow-pink", color: "hotpink" } //World Swap
      ])
      .enter()
      .append("marker")
      .attr("id", d => d.id)
      .attr("viewBox", "0 -5 10 10")
      .attr("refX", 12)
      .attr("refY", 0)
      .attr("markerWidth", 7)
      .attr("markerHeight", 7)
      .attr("orient", "auto")
      .append("path")
      .attr("d", "M0,-5L10,0L0,5")
      .attr("fill", d => d.color);


    function closePanel() {
          const panel = document.getElementById("side-panel");
          panel.classList.remove("open");
          document.getElementById("panel-content").innerHTML = "";
    }
    document.getElementById("close-panel-btn").addEventListener("click", closePanel);



    d3.json("dark_graph_data_cleaned.json").then(data => {
      const toISODate = d3.timeFormat("%Y-%m-%d");
      const fromEuropeanDate = d3.timeParse("%d-%m-%Y");
      const nodeMap = {};
      data.nodes.forEach(d => {
        const parsed = fromEuropeanDate(d.date);
        if (parsed) d.date = toISODate(parsed);
        nodeMap[d.id] = d;
      });
      const allDates = [...new Set(data.nodes.map(d => d.date))].sort();
      const spacing = 50; // aumenta da default (circa 50) a 150 per triplicare la distanza
      const xScale = d3.scalePoint()
        .domain(allDates)
        .range([200, 200 + spacing * (allDates.length - 1)])
        .padding(1.0);

      const yOffsets = {};
      worlds.forEach(world => yOffsets[world] = {});
      data.nodes.forEach(node => {
        const world = normalizeWorld(node.world);
        if (!yOffsets[world][node.date]) yOffsets[world][node.date] = [];
        yOffsets[world][node.date].push(node.id);
      });

      const minNodeSpacing = 22;
      const worldMaxCounts = {};
      worlds.forEach(world => {
        worldMaxCounts[world] = d3.max(Object.values(yOffsets[world]), arr => arr.length) || 1;
      });

      const worldBandHeights = {};
      worlds.forEach(world => {
        const count = worldMaxCounts[world];
        worldBandHeights[world] = Math.max(80, count * minNodeSpacing + 20);
      });

      const height = d3.sum(Object.values(worldBandHeights));
      svg.attr("height", height);

      const yWorldOffsets = {};
      let cumulativeY = 0;
      worlds.forEach(world => {
        yWorldOffsets[world] = cumulativeY;
        cumulativeY += worldBandHeights[world];
      });


      //INIZIO AGGIUNTA TIMELINE RAGGRUPPATA SUPERIORE - ELIMINARE FINO ALLA FINE PER RIMUOVERE
      const timeBands = [
        { start: 1850, end: 1899, label: "1850–1899" },
        { start: 1900, end: 1949, label: "1900–1949" },
        { start: 1950, end: 1999, label: "1950–1999" },
        { start: 2000, end: 2049, label: "2000–2049" },
        { start: 2050, end: 2100, label: "2050+" }
      ];
      const bandGroup = zoomLayer.append("g").attr("class", "top-timebands");
      // Trova le date esistenti per l’intervallo
      timeBands.forEach((band, i) => {
        const matchingDates = allDates.filter(d => {
          const y = new Date(d).getFullYear();
          return y >= band.start && y <= band.end;
        });
        if (matchingDates.length === 0) return;
        const x0 = xScale(matchingDates[0]);
        const x1 = xScale(matchingDates[matchingDates.length - 1]);
        if (x0 !== undefined && x1 !== undefined) {
          const width = x1 - x0 + 30;
          bandGroup.append("rect")
            .attr("x", x0 - 15)
            .attr("y", -30) // posizione sopra il grafo
            .attr("width", width)
            .attr("height", 30)
            .attr("fill", "rgba(220,220,220,0.8)")
            .attr("stroke", "#aaa");
          bandGroup.append("text")
            .attr("x", x0 + width / 2)
            .attr("text-anchor", "middle")
            .attr("y", -10)
            .text(band.label)
            .attr("font-size", "25px")
            .attr("font-weight", "bold")
            .attr("fill", "#333");
        }
      });
      //FINE TIMELINE RAGGRUPPATA SUPERIORE

      function normalizeWorld(w) {
        if (w.includes("Martha")) return "Martha";
        if (w.includes("Jonas")) return "Jonas";
        return "Origin";
      }

      function groupNodes() {
        const groups = [], visited = new Set();
        data.nodes.forEach(node => {
          if (visited.has(node.id)) return;
          const world = normalizeWorld(node.world);
          const date = node.date;
          const sameDateNodes = data.nodes.filter(n => n.date === date && normalizeWorld(n.world) === world);
          const connected = new Set([node.id]);
          let changed = true;
          while (changed) {
            changed = false;
            data.edges.forEach(edge => {
              const s = edge.source, t = edge.target;
              if (connected.has(s) && sameDateNodes.some(n => n.id === t) && !connected.has(t)) { connected.add(t); changed = true; }
              if (connected.has(t) && sameDateNodes.some(n => n.id === s) && !connected.has(s)) { connected.add(s); changed = true; }
            });
          }
          const ids = Array.from(connected);
          groups.push({ ids, representative: node, exploded: false });
          ids.forEach(id => visited.add(id));
        });
        return groups;
      }

      const groups = groupNodes();

      function yOffsetScale(node) {
  const world = normalizeWorld(node.world);
  const bandTop = yWorldOffsets[world];
  const bandHeight = worldBandHeights[world];
  const bandBottom = bandTop + bandHeight;

  if (node.isGroup && node.group) {
    const ys = node.group.ids.map(id => {
      const n = nodeMap[id];
      const ids = yOffsets[world][n.date] || [n.id];
      const count = ids.length;
      const step = Math.max(minNodeSpacing, (bandHeight - 20) / count);
      const index = ids.indexOf(n.id);
      const totalHeight = (count - 1) * step;
      const centerY = bandTop + bandHeight / 2;
      return Math.max(bandTop + 10, Math.min(bandBottom - 10, centerY + index * step - totalHeight / 2));
    });
    return d3.mean(ys);
  }

  const ids = yOffsets[world][node.date] || [node.id];
  if (!ids.includes(node.id)) ids.push(node.id);
  const count = ids.length;
  const step = Math.max(minNodeSpacing, (bandHeight - 20) / count);
  const index = ids.indexOf(node.id);
  const totalHeight = (count - 1) * step;
  const centerY = bandTop + bandHeight / 2;
  const y = centerY + index * step - totalHeight / 2;

  return Math.max(bandTop + 10, Math.min(bandBottom - 10, y));
      }

      function render() {
        // Ripristina assi
        zoomLayer.append("g")
          .attr("class", "axis")
          .attr("transform", `translate(0, ${height - 10})`)
          .call(d3.axisBottom(xScale).tickSizeOuter(0).tickPadding(10))
          .selectAll("text")
          .attr("text-anchor", "end")
          .attr("transform", "rotate(-45)")
          .attr("dx", "-0.5em")
          .attr("dy", "0.25em");

        const yScaleWorld = d3.scalePoint()
          .domain(worlds)
          .range(worlds.map(w => yWorldOffsets[w] + worldBandHeights[w] / 2));

        zoomLayer.selectAll(".axis-y").remove();

        zoomLayer.append("g")
          .attr("class", "axis axis-y")
          .attr("transform", `translate(150, 0)`)
          .call(d3.axisLeft(yScaleWorld));
        zoomLayer.selectAll(".node, .link, .world-bg, .world-label").remove(); // mantieni gli assi per renderli persistenti

        const nodesToRender = [];
        groups.forEach(g => {
          if (g.exploded) {
            g.ids.forEach(id => nodesToRender.push(nodeMap[id]));
          } else {
            const rep = g.representative;
            const label = g.ids.length === 1 ? rep.label : g.ids.length + " eventi";
            const characters = g.ids.length === 1 ? rep.characters : [];

            nodesToRender.push({
              id: g.ids.join(","),
              label,
              date: rep.date,
              world: normalizeWorld(rep.world),
              isGroup: g.ids.length > 1,
              group: g,
              size: g.ids.length,
              characters: g.ids.length === 1 ? rep.characters : []
            });
          }
        });

        zoomLayer.selectAll(".world-bg")
          .data(worlds).enter()
          .append("rect")
          .attr("class", "world-bg")
          .attr("x", 0)
          .attr("y", d => yWorldOffsets[d])
          .attr("width", 200 + spacing * (allDates.length - 1))
          .attr("height", d => worldBandHeights[d])
          .attr("fill", d => colorMap[d]);

        zoomLayer.selectAll(".world-label")
          .data(worlds).enter()
          .append("text")
          .attr("class", "world-label")
          .attr("x", 10)
          .attr("y", d => yWorldOffsets[d] + worldBandHeights[d] / 2)
          .attr("dy", "0.35em")
          .attr("text-anchor", "start")
          .attr("transform", d => `rotate(-90, 10, ${yWorldOffsets[d] + worldBandHeights[d] / 2})`)
          .text(d => d)

        const idToNode = Object.fromEntries(nodesToRender.map(n => [n.id, n]));

        const positionMap = {};
data.nodes.forEach(d => {
  const nodeObj = {
    id: d.id,
    date: d.date,
    world: normalizeWorld(d.world)
  };
  positionMap[d.id] = {
    x: xScale(d.date),
    y: yOffsetScale(nodeObj)
  };
});
nodesToRender.forEach(d => {
  positionMap[d.id] = {
    x: xScale(d.date),
    y: yOffsetScale(d)
  };
});

const edgesToRender = data.edges.map(e => {
  const sourceGroup = groups.find(g => g.ids.includes(e.source));
  const targetGroup = groups.find(g => g.ids.includes(e.target));
  const source = sourceGroup.exploded ? e.source : sourceGroup.ids.join(",");
  const target = targetGroup.exploded ? e.target : targetGroup.ids.join(",");

  const dx = positionMap[target].x - positionMap[source].x;
  const dy = positionMap[target].y - positionMap[source].y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const offset = 8;
  const ratio = dist > 0 ? (offset / dist) : 0;

  const x1 = positionMap[source].x + dx * ratio;
  const y1 = positionMap[source].y + dy * ratio;
  const x2 = positionMap[target].x - dx * ratio;
  const y2 = positionMap[target].y - dy * ratio;

  return {
    ...e,
    source,
    target,
    x1,
    y1,
    x2,
    y2
  };
});

        zoomLayer.selectAll(".link")
          .data(edgesToRender).enter()
          .append("line")
          .attr("class", d => `link link-${d.id}`)
          .attr("x1", d => d.x1)
          .attr("y1", d => d.y1)
          .attr("x2", d => d.x2)
          .attr("y2", d => d.y2)
          //.attr("marker-end", "url(#arrow)")
          //modifica colore marker end per tipi specifici
          .attr("marker-end", d => {
              if (d.type === "Succesfull Time Travel") return "url(#arrow-blue)";
              if (d.type === "Failed Time Travel") return "url(#arrow-orange)";
              if (d.type === "World Swap") return "url(#arrow-pink)";
              return "url(#arrow)";
          })
          //modifica colore linea per Successful Time Travel
          .style("stroke", d => {
            if (d.type === "Succesfull Time Travel") return "#6495ED";
            if (d.type === "Failed Time Travel") return "#FF6A00";
            if (d.type === "World Swap") return "hotpink";
            return "#999"
          })



          .attr("stroke-dasharray", d => d.type === "dashed arrow" ? "5,5" : null)
          .on("mouseover", function(event, d) {
            d3.select(this).classed("highlighted", true).attr("marker-end", "url(#arrow-red)");
            d3.selectAll(`[data-id='${d.source}'], [data-id='${d.target}']`).classed("highlighted", true);
            tooltip.style("display", "block")
              .html(`<strong>${d.type || 'Arco'}</strong><br><em>Sorgente:</em> ${d.source}<br><em>Destinazione:</em> ${d.target}`);
          })
          .on("mousemove", event => {
            tooltip.style("left", event.pageX + 10 + "px").style("top", event.pageY + "px");
          })
          .on("mouseout", function(event, d) {
            d3.select(this).classed("highlighted", false).attr("marker-end", "url(#arrow)");
            d3.selectAll(`[data-id='${d.source}'], [data-id='${d.target}']`).classed("highlighted", false);
            tooltip.style("display", "none");
          });

          zoomLayer.selectAll(".node")
      .data(nodesToRender).enter()
      .append(d => {
        const isTrigger = d.important_trigger || (d.isGroup && d.group && d.group.ids.some(id => nodeMap[id]?.important_trigger));
        return isTrigger ? document.createElementNS(d3.namespaces.svg, "path") : document.createElementNS(d3.namespaces.svg, "circle");
      })
      .attr("class", "node")
      .attr("data-id", d => d.id)
      .attr("transform", d => `translate(${xScale(d.date)},${yOffsetScale(d)})`)
      .attr("d", d => {
        const isTrigger = d.important_trigger || (d.isGroup && d.group && d.group.ids.some(id => nodeMap[id]?.important_trigger));
        if (isTrigger) {
          const baseSize = d.isGroup ? 6 + Math.sqrt(d.size) * 2 : 6;
          const size = baseSize * 1.5;
          const height = size * Math.sqrt(3) / 2;
          return `M 0 ${-height/2} L ${-size/2} ${height/2} L ${size/2} ${height/2} Z`;
        }
        return null;
      })
      .attr("r", d => {
        const isTrigger = d.important_trigger || (d.isGroup && d.group && d.group.ids.some(id => nodeMap[id]?.important_trigger));
        return isTrigger ? null : (d.isGroup ? 6 + Math.sqrt(d.size) * 2 : 6);
      })
      .style("fill", d => {
        const hasDeath = d.death || (d.isGroup && d.group && d.group.ids.some(id => nodeMap[id]?.death));
        return hasDeath ? "red" : "black";
      })
      .on("mouseover", (event, d) => {
        tooltip.style("display", "block")
          .html(`<strong>${d.label}</strong>`);
        const idList = d.group ? d.group.ids : [d.id];
        const incoming = data.edges.filter(e => idList.includes(e.target));
        const outgoing = data.edges.filter(e => idList.includes(e.source));
        d3.select(`[data-id='${d.id}']`).classed("red", true);
        incoming.forEach(e => {
          d3.select(`.link-${e.id}`).classed("purple", true).attr("marker-end", "url(#arrow-purple)");
          d3.select(`[data-id='${e.source}']`).classed("purple", true);
        });
        outgoing.forEach(e => {
          d3.select(`.link-${e.id}`).classed("green", true).attr("marker-end", "url(#arrow-green)");
          d3.select(`[data-id='${e.target}']`).classed("green", true);
        });
      })
      .on("mousemove", event => {
        tooltip.style("left", event.pageX + 10 + "px").style("top", event.pageY + "px");
      })
      .on("mouseout", () => {
        tooltip.style("display", "none");
        d3.selectAll(".node").classed("red green purple", false);
        d3.selectAll(".link").classed("green", false).classed("purple", false).attr("marker-end", "url(#arrow)");
      })
      .on("click", (event, d) => {
        if (!d.isGroup) openPanel(d);
        if (d.isGroup && d.group) {
          d.group.exploded = true;
          render();
        }
      });

        function getPhotoFilename(charName, date) {
          if (!date) return null;
          const yearPrefix = date.split("-")[0].substring(0, 3);
          let name = charName.replace(/\s\([A-Z]\)/, "").replace(/\//g, "__").replace(/ /g, "_");
          return `${name}_in_${yearPrefix}.jpg`;
        }

        function openPanel(nodeData) {
          const content = document.getElementById("panel-content");
          const title = `<h2 style="margin-bottom: 20px;">${nodeData.label}</h2>`;
          const date = nodeData.date;
          const yearPrefix = date ? date.split("-")[0].substring(0, 3) : "";
          const characters = Array.isArray(nodeData.characters) ? nodeData.characters : [];
          const charactersHtml = characters.map(char => {
            let name = char.replace(/\s\([A-Z]\)/, "").replace(/\//g, "__").replace(/ /g, "_");
            const photoWithYear = `${name}_in_${yearPrefix}.jpg`;
            const photoWithoutYear = `${name}.jpg`;
            return `
              <div style="background-color: #000; border-radius: 16px; overflow: hidden; box-shadow: 0 4px 20px rgba(0,0,0,0.6); margin-bottom: 30px; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">
                <img src="photo/${photoWithYear}" alt="${char}" style="width: 100%; height: auto; display: block;" onerror="this.onerror=null; this.src='photo/${photoWithoutYear}'">
                <div style="padding: 10px 15px; background-color: #000; color: white; text-align: center; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 18px; letter-spacing: 0.5px;">${char}</div>
              </div>
            `;
          }).join("");
          content.innerHTML = title + charactersHtml;
          document.getElementById("side-panel").classList.add("open");
        }



        d3.select("#resetView").on("click", () => {
          groups.forEach(g => g.exploded = false);
          render();
        });
      }

      render();
    });
  </script>
</body>
</html>
