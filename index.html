<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Dark Graph Timeline</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <button id="resetView">Reset Vista Compatta</button>
  <svg></svg>
  <div class="tooltip" style="display: none;"></div>
  <script>
    const svg = d3.select("svg");
    const tooltip = d3.select(".tooltip");
    const width = window.innerWidth;
    const colorMap = { "Martha": "#fbe18c", "Jonas": "#a1e6a1", "Origin": "#b6d8ff" };
    const worlds = ["Martha", "Jonas", "Origin"];
    const zoomLayer = svg.append("g").attr("class", "zoom-layer");
    const zoom = d3.zoom().scaleExtent([0.2, 10]).on("zoom", (event) => {
      zoomLayer.attr("transform", event.transform);
      tooltip.style("transform", "scale(1)");
    });
    svg.call(zoom);

    svg.append("defs").selectAll("marker")
      .data([
        { id: "arrow", color: "#ccc" },
        { id: "arrow-red", color: "red" },
        { id: "arrow-green", color: "green" },
        { id: "arrow-purple", color: "purple" },
      ])
      .enter()
      .append("marker")
      .attr("id", d => d.id)
      .attr("viewBox", "0 -5 10 10")
      .attr("refX", 12)
      .attr("refY", 0)
      .attr("markerWidth", 7)
      .attr("markerHeight", 7)
      .attr("orient", "auto")
      .append("path")
      .attr("d", "M0,-5L10,0L0,5")
      .attr("fill", d => d.color);

    d3.json("dark_graph_data_cleaned.json").then(data => {
      const toISODate = d3.timeFormat("%Y-%m-%d");
      const fromEuropeanDate = d3.timeParse("%d-%m-%Y");
      const nodeMap = {};
      data.nodes.forEach(d => {
        const parsed = fromEuropeanDate(d.date);
        if (parsed) d.date = toISODate(parsed);
        nodeMap[d.id] = d;
      });
      const allDates = [...new Set(data.nodes.map(d => d.date))].sort();
      const spacing = 50; // aumenta da default (circa 50) a 150 per triplicare la distanza
      const xScale = d3.scalePoint()
        .domain(allDates)
        .range([200, 200 + spacing * (allDates.length - 1)])
        .padding(1.0);

      const yOffsets = {};
      worlds.forEach(world => yOffsets[world] = {});
      data.nodes.forEach(node => {
        const world = normalizeWorld(node.world);
        if (!yOffsets[world][node.date]) yOffsets[world][node.date] = [];
        yOffsets[world][node.date].push(node.id);
      });

      const minNodeSpacing = 22;
      const worldMaxCounts = {};
      worlds.forEach(world => {
        worldMaxCounts[world] = d3.max(Object.values(yOffsets[world]), arr => arr.length) || 1;
      });

      const worldBandHeights = {};
      worlds.forEach(world => {
        const count = worldMaxCounts[world];
        worldBandHeights[world] = Math.max(80, count * minNodeSpacing + 20);
      });

      const height = d3.sum(Object.values(worldBandHeights));
      svg.attr("height", height);

      const yWorldOffsets = {};
      let cumulativeY = 0;
      worlds.forEach(world => {
        yWorldOffsets[world] = cumulativeY;
        cumulativeY += worldBandHeights[world];
      });

      function normalizeWorld(w) {
        if (w.includes("Martha")) return "Martha";
        if (w.includes("Jonas")) return "Jonas";
        return "Origin";
      }

      function groupNodes() {
        const groups = [], visited = new Set();
        data.nodes.forEach(node => {
          if (visited.has(node.id)) return;
          const world = normalizeWorld(node.world);
          const date = node.date;
          const sameDateNodes = data.nodes.filter(n => n.date === date && normalizeWorld(n.world) === world);
          const connected = new Set([node.id]);
          let changed = true;
          while (changed) {
            changed = false;
            data.edges.forEach(edge => {
              const s = edge.source, t = edge.target;
              if (connected.has(s) && sameDateNodes.some(n => n.id === t) && !connected.has(t)) { connected.add(t); changed = true; }
              if (connected.has(t) && sameDateNodes.some(n => n.id === s) && !connected.has(s)) { connected.add(s); changed = true; }
            });
          }
          const ids = Array.from(connected);
          groups.push({ ids, representative: node, exploded: false });
          ids.forEach(id => visited.add(id));
        });
        return groups;
      }

      const groups = groupNodes();

      function yOffsetScale(node) {
  const world = normalizeWorld(node.world);
  const bandTop = yWorldOffsets[world];
  const bandHeight = worldBandHeights[world];
  const bandBottom = bandTop + bandHeight;

  if (node.isGroup && node.group) {
    const ys = node.group.ids.map(id => {
      const n = nodeMap[id];
      const ids = yOffsets[world][n.date] || [n.id];
      const count = ids.length;
      const step = Math.max(minNodeSpacing, (bandHeight - 20) / count);
      const index = ids.indexOf(n.id);
      const totalHeight = (count - 1) * step;
      const centerY = bandTop + bandHeight / 2;
      return Math.max(bandTop + 10, Math.min(bandBottom - 10, centerY + index * step - totalHeight / 2));
    });
    return d3.mean(ys);
  }

  const ids = yOffsets[world][node.date] || [node.id];
  if (!ids.includes(node.id)) ids.push(node.id);
  const count = ids.length;
  const step = Math.max(minNodeSpacing, (bandHeight - 20) / count);
  const index = ids.indexOf(node.id);
  const totalHeight = (count - 1) * step;
  const centerY = bandTop + bandHeight / 2;
  const y = centerY + index * step - totalHeight / 2;

  return Math.max(bandTop + 10, Math.min(bandBottom - 10, y));
      }

      function render() {
        // Ripristina assi
        zoomLayer.append("g")
          .attr("class", "axis")
          .attr("transform", `translate(0, ${height - 10})`)
          .call(d3.axisBottom(xScale).tickSizeOuter(0).tickPadding(10))
          .selectAll("text")
          .attr("text-anchor", "end")
          .attr("transform", "rotate(-45)")
          .attr("dx", "-0.5em")
          .attr("dy", "0.25em");

        const yScaleWorld = d3.scalePoint()
          .domain(worlds)
          .range(worlds.map(w => yWorldOffsets[w] + worldBandHeights[w] / 2));

        zoomLayer.selectAll(".axis-y").remove();

        zoomLayer.append("g")
          .attr("class", "axis axis-y")
          .attr("transform", `translate(150, 0)`)
          .call(d3.axisLeft(yScaleWorld));
        zoomLayer.selectAll(".node, .link, .world-bg, .world-label").remove(); // mantieni gli assi per renderli persistenti

        const nodesToRender = [];
        groups.forEach(g => {
          if (g.exploded) {
            g.ids.forEach(id => nodesToRender.push(nodeMap[id]));
          } else {
            const rep = g.representative;
            const label = g.ids.length === 1 ? rep.label : g.ids.length + " eventi";
            nodesToRender.push({
              id: g.ids.join(","),
              label,
              date: rep.date,
              world: normalizeWorld(rep.world),
              isGroup: g.ids.length > 1,
              group: g,
              size: g.ids.length
            });
          }
        });

        zoomLayer.selectAll(".world-bg")
          .data(worlds).enter()
          .append("rect")
          .attr("class", "world-bg")
          .attr("x", 0)
          .attr("y", d => yWorldOffsets[d])
          .attr("width", 200 + spacing * (allDates.length - 1))
          .attr("height", d => worldBandHeights[d])
          .attr("fill", d => colorMap[d]);

        zoomLayer.selectAll(".world-label")
          .data(worlds).enter()
          .append("text")
          .attr("class", "world-label")
          .attr("x", 10)
          .attr("y", d => yWorldOffsets[d] + worldBandHeights[d] / 2)
          .attr("dy", "0.35em")
          .attr("text-anchor", "start")
          .attr("transform", d => `rotate(-90, 10, ${yWorldOffsets[d] + worldBandHeights[d] / 2})`)
          .text(d => d)

        const idToNode = Object.fromEntries(nodesToRender.map(n => [n.id, n]));

        const positionMap = {};
data.nodes.forEach(d => {
  const nodeObj = {
    id: d.id,
    date: d.date,
    world: normalizeWorld(d.world)
  };
  positionMap[d.id] = {
    x: xScale(d.date),
    y: yOffsetScale(nodeObj)
  };
});
nodesToRender.forEach(d => {
  positionMap[d.id] = {
    x: xScale(d.date),
    y: yOffsetScale(d)
  };
});

const edgesToRender = data.edges.map(e => {
  const sourceGroup = groups.find(g => g.ids.includes(e.source));
  const targetGroup = groups.find(g => g.ids.includes(e.target));
  const source = sourceGroup.exploded ? e.source : sourceGroup.ids.join(",");
  const target = targetGroup.exploded ? e.target : targetGroup.ids.join(",");

  const dx = positionMap[target].x - positionMap[source].x;
  const dy = positionMap[target].y - positionMap[source].y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const offset = 8;
  const ratio = dist > 0 ? (offset / dist) : 0;

  const x1 = positionMap[source].x + dx * ratio;
  const y1 = positionMap[source].y + dy * ratio;
  const x2 = positionMap[target].x - dx * ratio;
  const y2 = positionMap[target].y - dy * ratio;

  return {
    ...e,
    source,
    target,
    x1,
    y1,
    x2,
    y2
  };
});

        zoomLayer.selectAll(".link")
          .data(edgesToRender).enter()
          .append("line")
          .attr("class", d => `link link-${d.id}`)
          .attr("x1", d => d.x1)
          .attr("y1", d => d.y1)
          .attr("x2", d => d.x2)
          .attr("y2", d => d.y2)
          .attr("marker-end", "url(#arrow)")
          .on("mouseover", function(event, d) {
            d3.select(this).classed("highlighted", true).attr("marker-end", "url(#arrow-red)");
            d3.selectAll(`[data-id='${d.source}'], [data-id='${d.target}']`).classed("highlighted", true);
            tooltip.style("display", "block")
              .html(`<strong>${d.type || 'Arco'}</strong><br><em>Sorgente:</em> ${d.source}<br><em>Destinazione:</em> ${d.target}`);
          })
          .on("mousemove", event => {
            tooltip.style("left", event.pageX + 10 + "px").style("top", event.pageY + "px");
          })
          .on("mouseout", function(event, d) {
            d3.select(this).classed("highlighted", false).attr("marker-end", "url(#arrow)");
            d3.selectAll(`[data-id='${d.source}'], [data-id='${d.target}']`).classed("highlighted", false);
            tooltip.style("display", "none");
          });

        zoomLayer.selectAll(".node")
          .data(nodesToRender).enter()
          .append("circle")
          .attr("class", "node")
          .attr("data-id", d => d.id)
          .attr("r", d => d.isGroup ? 6 + Math.sqrt(d.size) * 2 : 6)
          .attr("cx", d => xScale(d.date))
          .attr("cy", d => yOffsetScale(d))
          .on("mouseover", (event, d) => {
            tooltip.style("display", "block")
              .html(`<strong>${d.label}</strong>`);
            const idList = d.group ? d.group.ids : [d.id];
            const incoming = data.edges.filter(e => idList.includes(e.target));
            const outgoing = data.edges.filter(e => idList.includes(e.source));
            d3.select(`[data-id='${d.id}']`).classed("red", true);
            incoming.forEach(e => {
              d3.select(`.link-${e.id}`).classed("purple", true).attr("marker-end", "url(#arrow-purple)");
              d3.select(`[data-id='${e.source}']`).classed("purple", true);
            });
            outgoing.forEach(e => {
              d3.select(`.link-${e.id}`).classed("green", true).attr("marker-end", "url(#arrow-green)");
              d3.select(`[data-id='${e.target}']`).classed("green", true);
            });
          })
          .on("mousemove", event => {
            tooltip.style("left", event.pageX + 10 + "px").style("top", event.pageY + "px");
          })
          .on("mouseout", () => {
            tooltip.style("display", "none");
            d3.selectAll(".node").classed("red green purple", false);
            d3.selectAll(".link").classed("green", false).classed("purple", false).attr("marker-end", "url(#arrow)");
          })
          .on("click", (event, d) => {
            if (d.isGroup && d.group) {
              d.group.exploded = true;
              render();
            }
          });

        d3.select("#resetView").on("click", () => {
          groups.forEach(g => g.exploded = false);
          render();
        });
      }

      render();
    });
  </script>
</body>
</html>
