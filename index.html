<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Dark Graph Timeline</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <link rel="stylesheet" href="style.css">
</head>
<body>

<div id="main-content">
    <div id="top-buttons">
      <button id="toggle-filter-btn">☰ Filtri</button>
      <button id="expandAll">Espandi Tutto</button>
      <button id="resetView">Vista Compatta</button>
    </div>
    <svg></svg>
    <div class="tooltip"></div>

  </div>

<!-- PANNELLO -->
<div id="filter-panel">
  <div id="filter-controls">
    <h3>Filtri</h3>
    <label><input type="checkbox" value="Jonas" class="world-filter" checked> Jonas</label><br>
    <label><input type="checkbox" value="Martha" class="world-filter" checked> Martha</label><br>
    <label><input type="checkbox" value="Origin" class="world-filter" checked> Origin</label><br>
    <hr>
    <label><input type="checkbox" id="filter-death"> Solo morti</label><br>
    <label><input type="checkbox" id="filter-trigger"> Solo eventi chiave</label>
    <hr>
    <label>Personaggi:</label><br>
    <div id="selected-characters" style="margin-bottom: 10px;"></div>
    <input type="text" id="character-search" placeholder="Cerca personaggio..." style="width: 100%; padding: 5px; margin-bottom: 10px;">
    <div id="search-suggestions" style="border: 1px solid #ccc; max-height: 100px; overflow-y: auto; display: none;"></div>

    <label>
      <input type="radio" name="char-mode" value="or" checked> uno qualsiasi (OR)
    </label>
    <label>
      <input type="radio" name="char-mode" value="and"> tutti (AND)
    </label>

    </select>
    <hr>
    <label for="year-start">Da anno:</label>
    <input type="number" id="year-start" min="1888" max="2053" style="width: 70px;" />
    <br>
    <label for="year-end">A anno:</label>
    <input type="number" id="year-end" min="1888" max="2053" style="width: 70px;" />
  </div>
  <hr>
<div>
  <strong>Tipi di archi:</strong><br>
  <label><input type="checkbox" class="edge-type-filter" value="Normal" checked> Normal</label><br>
  <label><input type="checkbox" class="edge-type-filter" value="World Swap" checked> World Swap</label><br>
  <label><input type="checkbox" class="edge-type-filter" value="Succesfull Time Travel" checked> Successo viaggio</label><br>
  <label><input type="checkbox" class="edge-type-filter" value="Quantum Entanglement (Causality Break)" checked> Entanglement</label><br>
  <label><input type="checkbox" class="edge-type-filter" value="Failed Time Travel" checked> Fallimento viaggio</label><br>
  <label><input type="checkbox" class="edge-type-filter" value="dashed arrow" checked> Dashed</label><br>
  <label><input type="checkbox" class="edge-type-filter" value="Same Event" checked> Evento condiviso</label>
</div>


</div>

  <svg></svg>
  <div class="tooltip" style="display: none;"></div>
  <div id="side-panel">
    <button id="close-panel-btn" style="
      background: #444;
      color: #fff;
      border: none;
      padding: 10px 15px;
      cursor: pointer;
      margin-bottom: 20px;
    ">Chiudi</button>
    <div id="panel-content"></div>
  </div>

  <script>
    document.getElementById("toggle-filter-btn").addEventListener("click", () => {
      const panel = document.getElementById("filter-panel");
      panel.classList.toggle("open");
    });

    const svg = d3.select("svg");
    const tooltip = d3.select(".tooltip");
    const width = window.innerWidth;
    const colorMap = { "Martha": "#fbe18c", "Jonas": "#a1e6a1", "Origin": "#b6d8ff" };
    const worlds = ["Martha", "Jonas", "Origin"];
    const zoomLayer = svg.append("g").attr("class", "zoom-layer");
    const zoom = d3.zoom().scaleExtent([0.2, 10]).on("zoom", (event) => {
      zoomLayer.attr("transform", event.transform);
      tooltip.style("transform", "scale(1)");
    });
    svg.call(zoom);

    svg.append("defs").selectAll("marker")
      .data([
        { id: "arrow", color: "#999" },
        { id: "arrow-red", color: "red" },
        { id: "arrow-green", color: "green" },
        { id: "arrow-purple", color: "purple" },
        
        { id: "arrow-blue", color: "#6495ED" }, //Successful Time Travel
        { id: "arrow-orange", color: "#FF6A00" }, //Failed Time Travel
        { id: "arrow-pink", color: "hotpink" } //World Swap
      ])
      .enter()
      .append("marker")
      .attr("id", d => d.id)
      .attr("viewBox", "0 -5 10 10")
      .attr("refX", 12)
      .attr("refY", 0)
      .attr("markerWidth", 7)
      .attr("markerHeight", 7)
      .attr("orient", "auto")
      .append("path")
      .attr("d", "M0,-5L10,0L0,5")
      .attr("fill", d => d.color);


    function closePanel() {
          const panel = document.getElementById("side-panel");
          panel.classList.remove("open");
          document.getElementById("panel-content").innerHTML = "";
    }
    document.getElementById("close-panel-btn").addEventListener("click", closePanel);



    d3.json("dark_graph_data_cleaned.json").then(data => {
      const toISODate = d3.timeFormat("%Y-%m-%d");
      const fromEuropeanDate = d3.timeParse("%d-%m-%Y");
      const nodeMap = {};
      data.nodes.forEach(d => {
        const parsed = fromEuropeanDate(d.date);
        if (parsed) d.date = toISODate(parsed);
        nodeMap[d.id] = d;
      });

      const allCharacters = new Set();
      data.nodes.forEach(n => {
        if (Array.isArray(n.characters)) {
          n.characters.forEach(c => allCharacters.add(c));
        }
      });
      
      //MODIFICA
      /*const characterSelect = document.getElementById("character-select");
      Array.from(allCharacters).sort().forEach(name => {
        const option = document.createElement("option");
        option.value = name;
        option.textContent = name;
        characterSelect.appendChild(option);
      });*/
      const selectedCharactersContainer = document.getElementById("selected-characters");
      const characterSearchInput = document.getElementById("character-search");
      const searchSuggestions = document.getElementById("search-suggestions");

      let selectedCharacters = [];

      function updateSelectedCharacters() {
        selectedCharactersContainer.innerHTML = "";
        selectedCharacters.forEach(name => {
          const tag = document.createElement("span");
          tag.style.cssText = "display: inline-block; background: #eee; border: 1px solid #ccc; border-radius: 12px; padding: 2px 8px; margin: 2px; font-size: 12px;";
          tag.textContent = name;

          const removeBtn = document.createElement("span");
          removeBtn.textContent = " ✕";
          removeBtn.style.cssText = "cursor: pointer; color: red; margin-left: 4px;";
          removeBtn.onclick = () => {
            selectedCharacters = selectedCharacters.filter(c => c !== name);
            render();
            updateSelectedCharacters();
          };

          tag.appendChild(removeBtn);
          selectedCharactersContainer.appendChild(tag);
        });
        render();
      }

      characterSearchInput.addEventListener("input", () => {
        const query = characterSearchInput.value.toLowerCase();
        const suggestions = Array.from(allCharacters).filter(c => c.toLowerCase().includes(query) && !selectedCharacters.includes(c));

        searchSuggestions.innerHTML = "";
        if (suggestions.length === 0 || query === "") {
          searchSuggestions.style.display = "none";
          return;
        }

        suggestions.forEach(name => {
          const div = document.createElement("div");
          div.textContent = name;
          div.style.cssText = "padding: 4px; cursor: pointer;";
          div.onclick = () => {
            selectedCharacters.push(name);
            characterSearchInput.value = "";
            searchSuggestions.style.display = "none";
            updateSelectedCharacters();
          };
          searchSuggestions.appendChild(div);
        });
        searchSuggestions.style.display = "block";
      });

      const allDates = [...new Set(data.nodes.map(d => d.date))].sort();
      
      //inizio modifica
      // Mappa per alternare sfumature di colore per anno
      const yearColorMap = {};
      let toggle = false;
      allDates.forEach(d => {
        const year = new Date(d).getFullYear();
        if (!(year in yearColorMap)) {
          yearColorMap[year] = toggle ? 0.8 : 1.0;
          console.log("Anno identificato:", year, "→ intensità:", yearColorMap[year]);
          toggle = !toggle;
        }
      });
      //fine
      const spacing = 50; // aumenta da default (circa 50) a 150 per triplicare la distanza
      const xScale = d3.scalePoint()
        .domain(allDates)
        .range([200, 200 + spacing * (allDates.length - 1)])
        .padding(1.0);

      const yOffsets = {};
      worlds.forEach(world => yOffsets[world] = {});
      data.nodes.forEach(node => {
        const world = normalizeWorld(node.world);
        if (!yOffsets[world][node.date]) yOffsets[world][node.date] = [];
        yOffsets[world][node.date].push(node.id);
      });

      const minNodeSpacing = 22;
      const worldMaxCounts = {};
      worlds.forEach(world => {
        worldMaxCounts[world] = d3.max(Object.values(yOffsets[world]), arr => arr.length) || 1;
      });

      const worldBandHeights = {};
      worlds.forEach(world => {
        const count = worldMaxCounts[world];
        worldBandHeights[world] = Math.max(80, count * minNodeSpacing + 20);
      });

      const height = d3.sum(Object.values(worldBandHeights));
      svg.attr("height", height);

      const yWorldOffsets = {};
      let cumulativeY = 0;
      worlds.forEach(world => {
        yWorldOffsets[world] = cumulativeY;
        cumulativeY += worldBandHeights[world];
      });

      //inizio
        // Colorazione alternata per anno nelle fasce dei mondi
        // RETTANGOLI ANNUALI CON COLORE ALTERNATO PER MONDO
        const bgBandGroup = zoomLayer.append("g").attr("class", "year-colored-bands");
        worlds.forEach(world => {
          allDates.forEach(date => {
            const year = new Date(date).getFullYear();
            const x = xScale(date);
            if (x === undefined) return;

            const y = yWorldOffsets[world];
            const height = worldBandHeights[world];
            const width = spacing;

            bgBandGroup.append("rect")
              .attr("x", x - spacing / 2)
              .attr("y", y)
              .attr("width", width)
              .attr("height", height)
              .attr("fill", d3.color(colorMap[world]).darker(1 - yearColorMap[year]))
              .attr("opacity", 1); // puoi testare anche 0.8
          });
        });
        //fine

      function normalizeWorld(w) {
        if (!w) return "Origin";
        if (w.toLowerCase().includes("martha")) return "Martha";
        if (w.toLowerCase().includes("jonas")) return "Jonas";
        return "Origin";
      }


      function groupNodes() {
        const groups = [], visited = new Set();
        data.nodes.forEach(node => {
          if (visited.has(node.id)) return;
          const world = normalizeWorld(node.world);
          const date = node.date;
          const sameDateNodes = data.nodes.filter(n => n.date === date && normalizeWorld(n.world) === world);
          const connected = new Set([node.id]);
          let changed = true;
          while (changed) {
            changed = false;
            data.edges.forEach(edge => {
              const s = edge.source, t = edge.target;
              if (connected.has(s) && sameDateNodes.some(n => n.id === t) && !connected.has(t)) { connected.add(t); changed = true; }
              if (connected.has(t) && sameDateNodes.some(n => n.id === s) && !connected.has(s)) { connected.add(s); changed = true; }
            });
          }
          const ids = Array.from(connected);
          groups.push({ ids, representative: node, exploded: false });
          ids.forEach(id => visited.add(id));
        });
        return groups;
      }

      const groups = groupNodes();
        groups.forEach(g => g.exploded = false); // <- aggiungi qui
        render();
      function yOffsetScale(node) {
  const world = normalizeWorld(node.world);
  const bandTop = yWorldOffsets[world];
  const bandHeight = worldBandHeights[world];
  const bandBottom = bandTop + bandHeight;

  if (node.isGroup && node.group) {
    const ys = node.group.ids.map(id => {
      const n = nodeMap[id];
      const ids = yOffsets[world][n.date] || [n.id];
      const count = ids.length;
      const step = Math.max(minNodeSpacing, (bandHeight - 20) / count);
      const index = ids.indexOf(n.id);
      const totalHeight = (count - 1) * step;
      const centerY = bandTop + bandHeight / 2;
      return Math.max(bandTop + 10, Math.min(bandBottom - 10, centerY + index * step - totalHeight / 2));
    });
    return d3.mean(ys);
  }

  const ids = yOffsets[world][node.date] || [node.id];
  if (!ids.includes(node.id)) ids.push(node.id);
  const count = ids.length;
  const step = Math.max(minNodeSpacing, (bandHeight - 20) / count);
  const index = ids.indexOf(node.id);
  const totalHeight = (count - 1) * step;
  const centerY = bandTop + bandHeight / 2;
  const y = centerY + index * step - totalHeight / 2;

  return Math.max(bandTop + 10, Math.min(bandBottom - 10, y));
      }


function applyFilters() {
  const selectedWorlds = Array.from(document.querySelectorAll(".world-filter:checked")).map(cb => cb.value);
  const filterDeath = document.getElementById("filter-death").checked;
  const filterTrigger = document.getElementById("filter-trigger").checked;
 // const selectedCharacters = Array.from(document.getElementById("character-select").selectedOptions).map(opt => opt.value);
  const charMode = document.querySelector("input[name='char-mode']:checked")?.value || "or";

  const yearStart = parseInt(document.getElementById("year-start").value);
  const yearEnd = parseInt(document.getElementById("year-end").value);
  const selectedEdgeTypes = Array.from(document.querySelectorAll(".edge-type-filter:checked")).map(cb => cb.value);

  const nodesToRender = [];

  // 1. Trova tutti i nodi connessi da archi di tipo selezionato
  const connectedNodeIds = new Set();
  data.edges.forEach(e => {
    const type = e.type || "Normal";
    if (selectedEdgeTypes.includes(type)) {
      connectedNodeIds.add(e.source);
      connectedNodeIds.add(e.target);
    }
  });

  groups.forEach(g => {
    const nodeWorlds = g.ids.map(id => normalizeWorld(nodeMap[id].world));
    const allInSelectedWorlds = nodeWorlds.every(w => selectedWorlds.includes(w));
    if (!allInSelectedWorlds) return;

    const hasDeath = g.ids.some(id => nodeMap[id]?.death);
    const hasTrigger = g.ids.some(id => nodeMap[id]?.important_trigger);

    const inCharacterFilter = selectedCharacters.length === 0 || g.ids.some(id => {
      const chars = nodeMap[id]?.characters;
      if (!Array.isArray(chars)) return false;
      if (charMode === "or") {
        return selectedCharacters.some(c => chars.includes(c));
      } else {
        return selectedCharacters.every(c => chars.includes(c));
      }
    });


    const inTimeRange = g.ids.some(id => {
      const date = new Date(nodeMap[id].date);
      const y = date.getFullYear();
      return (!yearStart || y >= yearStart) && (!yearEnd || y <= yearEnd);
    });

    const connectedToEdge = g.ids.some(id => connectedNodeIds.has(id));
    if (!connectedToEdge) return;

    if (!inCharacterFilter || !inTimeRange) return;
    if (filterDeath && !hasDeath) return;
    if (filterTrigger && !hasTrigger) return;

    if (g.exploded) {
      g.ids.forEach(id => {
        const node = nodeMap[id];
        const world = normalizeWorld(node.world);
        const y = new Date(node.date).getFullYear();
        if (!selectedWorlds.includes(world)) return;
        if (!connectedNodeIds.has(id)) return;
        if (filterDeath && !node.death) return;
        if (filterTrigger && !node.important_trigger) return;
        if (selectedCharacters.length > 0) {
        if (!Array.isArray(node.characters)) return;
            const hasChars = charMode === "or"
              ? selectedCharacters.some(c => node.characters.includes(c))
              : selectedCharacters.every(c => node.characters.includes(c));
            if (!hasChars) return;
          }
        if ((yearStart && y < yearStart) || (yearEnd && y > yearEnd)) return;
        nodesToRender.push(node);
      });
    } else {
      const rep = g.representative;
      nodesToRender.push({
        id: g.ids.join(","),
        label: g.ids.length === 1 ? rep.label : g.ids.length + " eventi",
        date: rep.date,
        world: normalizeWorld(rep.world),
        isGroup: g.ids.length > 1,
        group: g,
        size: g.ids.length,
        characters: rep.characters
      });
    }
  });

  return nodesToRender;
}




      function render() {
        // Ripristina assi
        zoomLayer.append("g")
          .attr("class", "axis")
          .attr("transform", `translate(0, ${height - 10})`)
          .call(d3.axisBottom(xScale).tickSizeOuter(0).tickPadding(10))
          .selectAll("text")
          .attr("text-anchor", "end")
          .attr("transform", "rotate(-45)")
          .attr("dx", "-0.5em")
          .attr("dy", "0.25em");

        const yScaleWorld = d3.scalePoint()
          .domain(worlds)
          .range(worlds.map(w => yWorldOffsets[w] + worldBandHeights[w] / 2));

        zoomLayer.selectAll(".axis-y").remove();
        /*
        zoomLayer.append("g")
          .attr("class", "axis axis-y")
          .attr("transform", `translate(150, 0)`)
          .call(d3.axisLeft(yScaleWorld));
        */

        zoomLayer.selectAll(".node, .link, .world-bg, .world-label").remove(); // mantieni gli assi per renderli persistenti

       const nodesToRender = applyFilters();

        /*
        zoomLayer.selectAll(".world-bg")
          .data(worlds).enter()
          .append("rect")
          .attr("class", "world-bg")
          .attr("x", 0)
          .attr("y", d => yWorldOffsets[d])
          .attr("width", 200 + spacing * (allDates.length - 1))
          .attr("height", d => worldBandHeights[d])
          .attr("fill", d => colorMap[d]);
          */

        zoomLayer.selectAll(".world-label")
        .data(worlds).enter()
        .append("text")
        .attr("class", "world-label")
        .attr("text-anchor", "middle")
        .attr("transform", d => {
          const y = yWorldOffsets[d] + worldBandHeights[d] / 2;
          const x = 170; // puoi ridurre a 160, 150 ecc. per avvicinare ancora
          return `translate(${x},${y}) rotate(-90)`;
        })
        .text(d => d)
        .style("font-size", "24px")
        .style("fill", "#333");

        const idToNode = Object.fromEntries(nodesToRender.map(n => [n.id, n]));

        const positionMap = {};
data.nodes.forEach(d => {
  const nodeObj = {
    id: d.id,
    date: d.date,
    world: normalizeWorld(d.world)
  };
  positionMap[d.id] = {
    x: xScale(d.date),
    y: yOffsetScale(nodeObj)
  };
});
nodesToRender.forEach(d => {
  positionMap[d.id] = {
    x: xScale(d.date),
    y: yOffsetScale(d)
  };
});

const visibleNodeIds = new Set(nodesToRender.map(n => n.id));
const selectedEdgeTypes = Array.from(document.querySelectorAll(".edge-type-filter:checked")).map(cb => cb.value);
const edgesToRender = data.edges.map(e => {
  const sourceGroup = groups.find(g => g.ids.includes(e.source));
  const targetGroup = groups.find(g => g.ids.includes(e.target));

  const source = sourceGroup.exploded ? e.source : sourceGroup.ids.join(",");
  const target = targetGroup.exploded ? e.target : targetGroup.ids.join(",");

  if (!visibleNodeIds.has(source) || !visibleNodeIds.has(target)) return null;

  const edgeType = e.type || "__other__";
  if (!selectedEdgeTypes.includes(edgeType)) return null;

  const dx = positionMap[target].x - positionMap[source].x;
  const dy = positionMap[target].y - positionMap[source].y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const offset = 8;
  const ratio = dist > 0 ? (offset / dist) : 0;

  const x1 = positionMap[source].x + dx * ratio;
  const y1 = positionMap[source].y + dy * ratio;
  const x2 = positionMap[target].x - dx * ratio;
  const y2 = positionMap[target].y - dy * ratio;

  return {
    ...e,
    type: edgeType,
    source,
    target,
    x1,
    y1,
    x2,
    y2
  };
}).filter(d => d !== null);


        zoomLayer.selectAll(".link")
          .data(edgesToRender).enter()
          .append("line")
          .attr("class", d => `link link-${d.id}`)
          .attr("x1", d => d.x1)
          .attr("y1", d => d.y1)
          .attr("x2", d => d.x2)
          .attr("y2", d => d.y2)
          //.attr("marker-end", "url(#arrow)")
          //modifica colore marker end per tipi specifici
          .attr("marker-end", d => {
              if (d.type === "Succesfull Time Travel") return "url(#arrow-blue)";
              if (d.type === "Failed Time Travel") return "url(#arrow-orange)";
              if (d.type === "World Swap") return "url(#arrow-pink)";
              return "url(#arrow)";
          })
          //modifica colore linea per Successful Time Travel
          .style("stroke", d => {
            if (d.type === "Succesfull Time Travel") return "#6495ED";
            if (d.type === "Failed Time Travel") return "#FF6A00";
            if (d.type === "World Swap") return "hotpink";
            return "#999"
          })



          .attr("stroke-dasharray", d => d.type === "dashed arrow" ? "5,5" : null)
          .on("mouseover", function(event, d) {
            d3.select(this)
              .classed("highlighted", true)
              .style("stroke-width", "4px");  // Aumenta spessore al passaggio
            d3.selectAll(`[data-id='${d.source}'], [data-id='${d.target}']`)
              .classed("highlighted", true);

            tooltip.style("display", "block")
              .html(`<strong>${d.type || 'Arco'}</strong><br><em>Sorgente:</em> ${d.source}<br><em>Destinazione:</em> ${d.target}`);
          })
          .on("mousemove", event => {
            tooltip.style("left", event.pageX + 10 + "px").style("top", event.pageY + "px");
          })
          .on("mouseout", function(event, d) {
            d3.select(this)
              .classed("highlighted", false)
              .style("stroke-width", null);  // ✅ Torna al valore definito in CSS o style iniziale
            d3.selectAll(`[data-id='${d.source}'], [data-id='${d.target}']`)
              .classed("highlighted", false);

            tooltip.style("display", "none");
          });

      zoomLayer.selectAll(".node")
      .data(nodesToRender).enter()
      .append(d => {
        const isTrigger = d.important_trigger || (d.isGroup && d.group && d.group.ids.some(id => nodeMap[id]?.important_trigger));
        return isTrigger ? document.createElementNS(d3.namespaces.svg, "path") : document.createElementNS(d3.namespaces.svg, "circle");
      })
      .attr("class", "node")
      .attr("data-id", d => d.id)
      .attr("transform", d => `translate(${xScale(d.date)},${yOffsetScale(d)})`)
      .attr("d", d => {
        const isTrigger = d.important_trigger || (d.isGroup && d.group && d.group.ids.some(id => nodeMap[id]?.important_trigger));
        if (isTrigger) {
          const baseSize = d.isGroup ? 6 + Math.sqrt(d.size) * 2 : 6;
          const size = baseSize * 2.5;
          const height = size * Math.sqrt(3) / 2;
          return `M 0 ${-height/2} L ${-size/2} ${height/2} L ${size/2} ${height/2} Z`;
        }
        return null;
      })
      .attr("r", d => {
        const isTrigger = d.important_trigger || (d.isGroup && d.group && d.group.ids.some(id => nodeMap[id]?.important_trigger));
        return isTrigger ? null : (d.isGroup ? 6 + Math.sqrt(d.size) * 2 : 6);
      })
      .style("fill", d => {
        const hasDeath = d.death || (d.isGroup && d.group && d.group.ids.some(id => nodeMap[id]?.death));
        return hasDeath ? "red" : "black";
      })
      .on("mouseover", (event, d) => {
        tooltip.style("display", "block")
          .html(`<strong>${d.label}</strong>`);
        const idList = d.group ? d.group.ids : [d.id];
        const incoming = data.edges.filter(e => idList.includes(e.target));
        const outgoing = data.edges.filter(e => idList.includes(e.source));
        d3.select(`[data-id='${d.id}']`).classed("orange", true);
        incoming.forEach(e => {
          d3.select(`.link-${e.id}`).classed("purple", true).attr("marker-end", "url(#arrow-purple)");
          d3.select(`[data-id='${e.source}']`).classed("purple", true);
        });
        outgoing.forEach(e => {
          d3.select(`.link-${e.id}`).classed("green", true).attr("marker-end", "url(#arrow-green)");
          d3.select(`[data-id='${e.target}']`).classed("green", true);
        });
      })
      .on("mousemove", event => {
        tooltip.style("left", event.pageX + 10 + "px").style("top", event.pageY + "px");
      })
      .on("mouseout", () => {
        tooltip.style("display", "none");
        d3.selectAll(".node").classed("orange green purple", false);
        d3.selectAll(".link").classed("green", false).classed("purple", false).attr("marker-end", "url(#arrow)");
      })
      .on("click", (event, d) => {
        if (!d.isGroup) openPanel(d);
        if (d.isGroup && d.group) {
          d.group.exploded = true;
          render();
        }
      });

        function getPhotoFilename(charName, date) {
          if (!date) return null;
          const yearPrefix = date.split("-")[0].substring(0, 3);
          let name = charName.replace(/\s\([A-Z]\)/, "").replace(/\//g, "__").replace(/ /g, "_");
          return `${name}_in_${yearPrefix}.jpg`;
        }

        function openPanel(nodeData) {
          const content = document.getElementById("panel-content");
          const title = `<h2 style="margin-bottom: 20px;">${nodeData.label}</h2>`;
          const date = nodeData.date;
          const yearPrefix = date ? date.split("-")[0].substring(0, 3) : "";
          const characters = Array.isArray(nodeData.characters) ? nodeData.characters : [];
          const charactersHtml = characters.map(char => {
            let name = char.replace(/\s\([A-Z]\)/, "").replace(/\//g, "__").replace(/ /g, "_");
            const photoWithYear = `${name}_in_${yearPrefix}.jpg`;
            const photoWithoutYear = `${name}.jpg`;
            return `
              <div style="background-color: #000; border-radius: 16px; overflow: hidden; box-shadow: 0 4px 20px rgba(0,0,0,0.6); margin-bottom: 30px; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">
                <img src="photo/${photoWithYear}" alt="${char}" style="width: 100%; height: auto; display: block;" onerror="this.onerror=null; this.src='photo/${photoWithoutYear}'">
                <div style="padding: 10px 15px; background-color: #000; color: white; text-align: center; font-family: 'Segoe UI', sans-serif; font-weight: 600; font-size: 18px; letter-spacing: 0.5px;">${char}</div>
              </div>
            `;
          }).join("");
          content.innerHTML = title + charactersHtml;
          document.getElementById("side-panel").classList.add("open");
        }

        d3.select("#resetView").on("click", () => {
          groups.forEach(g => g.exploded = false);
          render();
        });

        d3.select("#expandAll").on("click", () => {
          groups.forEach(g => g.exploded = true);
          render();
         });

      }
            document.querySelectorAll(".world-filter, #filter-death, #filter-trigger")
        .forEach(el => el.addEventListener("change", render));
        document.getElementById("character-select").addEventListener("change", render);
        document.getElementById("year-start").addEventListener("input", render);
        document.getElementById("year-end").addEventListener("input", render);
        document.querySelectorAll(".edge-type-filter").forEach(cb => {cb.addEventListener("change", render);});


      render();
    });
  </script>
</body>
</html>

